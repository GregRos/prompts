# TypeScript rules
## Dependencies
> WHEN:
> - dependencies are involved.

ALWAYS check if package comes with type declarations
NEVER use packages without type declarations
ALWAYS try install `@types/package` if there are no type declarations
NEVER write type declarations for external packages
## Compilation
ALWAYS assume compilation is in strict mode
## Declarations
### Fields
PREFER `readonly` fields
PREFER constructor fields
### Top level
NEVER use `namespace` declarations
NEVER write code modifying `module`
NEVER use `export = X`, UNLESS required by an API
### Types
PREFER interfaces over type aliases
PREFER classes over interfaces
### Classes
PREFER defining an options object interface.
#### Constructors
ALWAYS use static factory functions when class init must be async
NEVER return broken/uninitialized instances from constructors
### Interfaces
WHEN defining an options interface for a class, call it `${Class}Options`
### Enums
ALWAYS use `1 << n` for values of flag enums
### Type parameters
CONSIDER sensible defaults for type parameters
## Annotations
NEVER add type annotations WHEN they can be inferred
### Any
NEVER leave declarations as implicit `any`
AVOID using `any`
CONSIDER using `any` WHEN value has arbitrary type
CONSIDER using `any` WHEN dependency lacks type declarations or they are broken.
PREFER using `any` WHEN working with opaque conditional types
### Type literals and expressions
NEVER annotate any symbol with object type literals
ONLY annotate parameters with function type literals, NEVER variables
AVOID annotating with conditional type expressions
NEVER annotate with union or intersection type expressions
AVOID duplicating type literals of all kinds
#### Exotics
NEVER use object literal types with call signatures
### Discriminants
ALWAYS use discriminants when defining object union types
CONSIDER avoiding discriminants if all types are classes
PREFER `string` discriminants
PREFER discriminants called `"type"`
## Code
NEVER pass an object expression when a class type is expected

