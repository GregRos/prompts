# TypeScript rules
## Dependencies
> WHEN:
> - dependencies are involved.

ALWAYS check if package comes with type declarations
NEVER use packages without type declarations
ALWAYS try install `@types/package` if there are no type declarations
NEVER write type declarations for external packages
## Compilation
ALWAYS assume compilation is in strict mode
## Declarations
### Fields
PREFER `readonly` fields
PREFER constructor fields
### Top level
NEVER use `namespace` declarations
NEVER write code modifying `module`
NEVER use `export = X`, UNLESS required by an API
### Types
PREFER interfaces over type aliases
PREFER classes over interfaces
### Classes
PREFER defining an options object interface.
AVOID constructors taking ~3 or more arguments

### Interfaces
WHEN defining an options interface, call it `${Class}Options`.
### Enums
NEVER use enums with string values
WHEN using flags enums, ALWAYS use `1 << X` for values

## Annotations
NEVER add type annotations when they can be inferred
### Any
NEVER leave declarations as implicit `any`
AVOID using `any`
### Type literals and expressions
NEVER annotate any symbol with object type literals
ONLY annotate parameters with function type literals, NEVER variables
AVOID annotating with conditional type expressions
NEVER annotate with union or intersection type expressions
AVOID duplicating type literals of all kinds
#### Exotics
NEVER use object literal types with call signatures
### Discriminants
ALWAYS use discriminants when defining object union types:
- CONSIDER avoiding discriminants if all types are classes
PREFER `string` discriminants
PREFER discriminants called `"type"`
## Code
NEVER pass an object expression when a class type is expected
## Type checking
WHEN finishing your turn after writing TypeScript code:
- MUST run `yarn build` to check for type errors
