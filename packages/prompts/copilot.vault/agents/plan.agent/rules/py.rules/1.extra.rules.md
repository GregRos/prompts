---
aliases:
  - plan py extra
---
# Planning Instructions
The following ADDITIONAL instructions are for planning, review, and design.



## Dataclasses
We PREFER data classes over ordinary ones, as this substantially reduces the amount of code that must be written.

HOWEVER, not all classes can be data classes. When defining a new class, ask yourself: DOES this class NEED to be a regular class? If so, WHY?

We ALWAYS use `__post_init__` when a data class needs extra initialization.

We ALWAYS use `field(...)` for dataclass attributes with default values.
## Collection-like Classes
We ENCOURAGE implementing the `Iterable` protocol on classes that are primarily collections of other values.

When implementing `Iterable`, we also CONSIDER which other protocols the class might implement. This includes: `Mapping`, `Sequence`, etc.
## Operators
Classes should define operators based on their qualities and the operations defined on them.
### __str__ or __repr__
If a class have a valid string representation. All classes should at least define `__str__`.
### __add__
If a class supports an addition or concatenation-like operation.
### __and__, __or__
Class is a filter, predicate, or similar; used to combine predicates. 
### __eq__
Instances of this class are not unique objects, but are primarily value-based. Most classes should implement this.
### __bool__
The class has an "empty" state.
### __call__
If a class represents an operation, instead of methods like `execute` etc.
### __len__
The class has a natural length property.
### __int__
The class has an integer representation.
## Members
We ALWAYS use `@cached_property` when declaring a property on a functionally immutable class, as this is in line with functional programming idioms.

When declaring `__lt__` or similar operators, we STRONGLY CONSIDER whether a class can also have `@total_ordering`.
## Abstract Classes and Protocols
We ENCOURAGE the use of both abstract clsses and protocols. They are a critical staple of OOP. HOWEVER, these elements must be annotated appropriately in order to make the intent clear to both engineers and type checkers:

1. We ALWAYS make sure abstract classes subclass `ABC`.
2. We ALWAYS decorate abstract members with `@abstractmethod`, making its role clear.
3. We ALWAYS subclass protocol classes from `Protocol`. It is not required however to implement a protocol by subclassing it.
4. ALL methods in protocols MUST use either `/` or `*` or both. This ensures they are broadly compatible with a more diverse range of implementations.

## Method and Class Stubs
When declaring a method, function, or class stub we ALWAYS use `...` for its body. 

This token is a clear signal the declaration is a *stub* rather than an unsupported operation.

## Private members
We use the Pythonic convention where underscores indicate a declaration is internal.

MOST declarations should be private.

## Avoid enums
Prefer Literal types over Enums, such as `Literal["a", "b"]`. Avoid enums